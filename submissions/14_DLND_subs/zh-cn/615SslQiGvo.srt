1
00:00:00,000 --> 00:00:02,350
现在我将介绍

2
00:00:02,350 --> 00:00:06,925
如何从这个 VGG 网络中获取

3
00:00:06,924 --> 00:00:08,533
这些卷积码

4
00:00:08,534 --> 00:00:10,199
我们将从这个花朵数据集中

5
00:00:10,199 --> 00:00:10,200
获取每个图片
我们将从这个花朵数据集中

6
00:00:10,200 --> 00:00:12,139
获取每个图片

7
00:00:12,140 --> 00:00:15,970
并传入卷积层进行运行

8
00:00:15,970 --> 00:00:19,730
从第一个完全连接的层级中获取卷积码

9
00:00:19,730 --> 00:00:21,670
这是从 TensorFlow VGG 源代码中

10
00:00:21,670 --> 00:00:24,010
复制的一段代码

11
00:00:24,010 --> 00:00:26,329
该网络获取一个

12
00:00:26,329 --> 00:00:26,330
244 x 244 x 3 的图片
该网络获取一个

13
00:00:26,330 --> 00:00:29,739
244 x 244 x 3 的图片

14
00:00:29,739 --> 00:00:32,739
并对其运行这个卷积层

15
00:00:32,740 --> 00:00:35,270
我们有两个卷积层

16
00:00:35,270 --> 00:00:38,340
最大池化 两个卷积层 最大池化

17
00:00:38,340 --> 00:00:41,092
然后三个卷积层 然后三个 然后三个

18
00:00:41,091 --> 00:00:42,549
最终

19
00:00:42,549 --> 00:00:43,959
得出完全连接的层级

20
00:00:43,960 --> 00:00:47,740
并传入 ReLU 激活函数

21
00:00:47,740 --> 00:00:53,170
我们实际上想获得这些值

22
00:00:53,170 --> 00:00:58,466
这个网络使用这些 ReLU 进行训练

23
00:00:58,466 --> 00:01:00,340
当我们获得卷积码后

24
00:01:00,340 --> 00:01:01,969
我们还想使用这些 ReLU

25
00:01:01,969 --> 00:01:01,970
改善效果
我们还想使用这些 ReLU

26
00:01:01,970 --> 00:01:03,890
改善效果

27
00:01:03,890 --> 00:01:06,650
构建网络很直观

28
00:01:06,650 --> 00:01:09,159
创建这个 VGG 对象

29
00:01:09,159 --> 00:01:09,160
并创建输入占位符 然后是 vgg.build
创建这个 VGG 对象

30
00:01:09,160 --> 00:01:14,558
并创建输入占位符 然后是 vgg.build

31
00:01:14,558 --> 00:01:16,849
该函数负责构建网络

32
00:01:16,849 --> 00:01:19,089
在 TensorFlow 中构建图表

33
00:01:19,090 --> 00:01:20,379
然后稍后使用

34
00:01:20,379 --> 00:01:20,380
我发现这个只需构建一次
然后稍后使用

35
00:01:20,380 --> 00:01:22,462
我发现这个只需构建一次

36
00:01:22,462 --> 00:01:26,349
如果多次运行 vgg.build

37
00:01:26,349 --> 00:01:29,259
就会将所有这些节点不断添加到图表上

38
00:01:29,260 --> 00:01:30,879
最终出现太多的节点

39
00:01:30,879 --> 00:01:30,880
在这个记事本中
最终出现太多的节点

40
00:01:30,880 --> 00:01:34,929
在这个记事本中

41
00:01:34,930 --> 00:01:38,049
确保整个过程中只运行 vgg.build 一次

42
00:01:38,049 --> 00:01:38,050
否则就会出现错误
确保整个过程中只运行 vgg.build 一次

43
00:01:38,050 --> 00:01:39,549
否则就会出现错误

44
00:01:39,549 --> 00:01:43,000
你需要重启记事本

45
00:01:43,000 --> 00:01:47,560
构建好网络和图表后

46
00:01:47,560 --> 00:01:50,950
然后我们需要从

47
00:01:50,950 --> 00:01:54,230
这个层级“relu6”中获取卷积码

48
00:01:54,230 --> 00:01:57,280
执行 sess.run relu6

49
00:01:57,280 --> 00:02:00,519
向其提供图片字典并获得卷积码

50
00:02:00,519 --> 00:02:05,004
这部分很简单

51
00:02:05,004 --> 00:02:07,019
但是当你真的去编写代码完成所有这些过程时

52
00:02:07,019 --> 00:02:09,008
实际上需要花点功夫才能都设置

53
00:02:09,008 --> 00:02:09,639
正确

54
00:02:09,639 --> 00:02:11,347
我将提供大部分代码

55
00:02:11,347 --> 00:02:13,219
但是需要你实现这部分

56
00:02:13,219 --> 00:02:15,800
以及获得卷积码部分

57
00:02:15,800 --> 00:02:18,840
这里导入各个内容

58
00:02:18,840 --> 00:02:21,969
utils 来自 tensorflow_vgg

59
00:02:21,969 --> 00:02:25,900
其中包含一些很实用的函数

60
00:02:25,900 --> 00:02:27,189
例如加载图片 等等

61
00:02:27,189 --> 00:02:30,340
这里是加载数据

62
00:02:30,340 --> 00:02:33,669
我们的数据位于 flower_photos

63
00:02:33,669 --> 00:02:33,670
然后是每个图片
我们的数据位于 flower_photos

64
00:02:33,670 --> 00:02:36,699
然后是每个图片

65
00:02:36,699 --> 00:02:39,250
每个类 有 5 个不同的类

66
00:02:39,250 --> 00:02:42,139
向日葵 雏菊 玫瑰 等等

67
00:02:42,139 --> 00:02:44,109
我列出了

68
00:02:44,110 --> 00:02:47,469
数据字典中的所有内容

69
00:02:47,469 --> 00:02:47,470
并获得类
数据字典中的所有内容

70
00:02:47,470 --> 00:02:50,109
并获得类

71
00:02:50,110 --> 00:02:52,939
下面这段代码将由你来实现

72
00:02:52,939 --> 00:02:52,940
首先 你将构建 VGG 网络
下面这段代码将由你来实现

73
00:02:52,940 --> 00:02:57,079
首先 你将构建 VGG 网络

74
00:02:57,080 --> 00:02:59,409
你将初始化类

75
00:02:59,409 --> 00:02:59,410
并构建类
你将初始化类

76
00:02:59,410 --> 00:03:01,599
并构建类

77
00:03:01,599 --> 00:03:03,340
在下面

78
00:03:03,340 --> 00:03:06,759
你将从 relu6 层级中获取卷积码

79
00:03:06,759 --> 00:03:08,620
这段代码的运行原理是

80
00:03:08,620 --> 00:03:11,710
你实际上对网络

81
00:03:11,710 --> 00:03:12,770
运行批次

82
00:03:12,770 --> 00:03:15,310
查看每个文件

83
00:03:15,310 --> 00:03:19,449
将图片附到一些批次上

84
00:03:19,449 --> 00:03:23,049
然后将批次连结到图片数组中

85
00:03:23,050 --> 00:03:24,729
你可以传入图片

86
00:03:24,729 --> 00:03:24,730
或者将图片提供给 VGG 网络
你可以传入图片

87
00:03:24,730 --> 00:03:28,569
或者将图片提供给 VGG 网络

88
00:03:28,569 --> 00:03:31,000
并获得 relu6 卷积码

89
00:03:31,000 --> 00:03:33,560
我们在这里加载图片

90
00:03:33,560 --> 00:03:36,189
这部分的作用是

91
00:03:36,189 --> 00:03:40,060
我们的图片不是 244 x 244

92
00:03:40,060 --> 00:03:43,389
即网络希望具有的尺寸

93
00:03:43,389 --> 00:03:43,390
所以这部分的作用是剪裁出图片中心部分
即网络希望具有的尺寸

94
00:03:43,390 --> 00:03:46,409
所以这部分的作用是剪裁出图片中心部分

95
00:03:46,409 --> 00:03:49,009
如果图片大于 244 x 244

96
00:03:49,009 --> 00:03:52,579
那么就会从中心剪裁 获得该大小的图片

97
00:03:52,580 --> 00:03:55,419
也有其他实现方法 也许更好

98
00:03:55,419 --> 00:03:55,420
你可以将原始图片缩小为
也有其他实现方法 也许更好

99
00:03:55,420 --> 00:03:58,629
你可以将原始图片缩小为

100
00:03:58,629 --> 00:04:03,009
期望的尺寸 或者通过其他方式

101
00:04:03,009 --> 00:04:07,299
将原始图片（输入图片）

102
00:04:07,300 --> 00:04:09,629
变成网络希望的形状

103
00:04:09,629 --> 00:04:09,630
如果你要进行迁移学习
变成网络希望的形状

104
00:04:09,630 --> 00:04:11,079
如果你要进行迁移学习

105
00:04:11,080 --> 00:04:13,120
基本上都会遇到这种情形

106
00:04:13,120 --> 00:04:16,300
因为所有这些卷积网络

107
00:04:16,300 --> 00:04:20,230
都根据一些原始尺寸的图片进行训练

108
00:04:20,230 --> 00:04:23,139
当你进行迁移学习时

109
00:04:23,139 --> 00:04:23,140
需要使用相同的尺寸
当你进行迁移学习时

110
00:04:23,140 --> 00:04:24,740
需要使用相同的尺寸

111
00:04:24,740 --> 00:04:27,879
我觉得缩小图片很常见

112
00:04:27,879 --> 00:04:30,399
这里我直接裁剪

113
00:04:30,399 --> 00:04:33,009
并且效果很好

114
00:04:33,009 --> 00:04:36,129
但是如果你缩小图片的话 可能更好

115
00:04:36,129 --> 00:04:39,370
我将请你构建这里的网络

116
00:04:39,370 --> 00:04:42,550
填写这些代码 并填写下面的代码

117
00:04:42,550 --> 00:04:43,480
加油

118
00:04:43,480 --> 00:04:46,540
如果遇到问题

119
00:04:46,540 --> 00:04:48,519
或者想要看看我是如何实现的

120
00:04:48,519 --> 00:04:48,520
可以观看我的解决方案视频
或者想要看看我是如何实现的

121
00:04:48,520 --> 00:04:51,029
可以观看我的解决方案视频

